#include <errno.h>
#include <stdint.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
 * Dependency-free (no third-party libraries) bitmap font generator.
 *
 * This tool emits C sources under src/core/font/.
 * It does NOT import external font formats (TTF/BDF/etc).
 *
 * For now the glyph shapes are defined directly in this file (authored in-repo)
 * and the generator provides:
 *  - consistent formatting
 *  - reproducible output
 *  - optional 8x16 generation via deterministic vertical scaling
 */

struct glyph8 {
	unsigned char ch;
	uint8_t rows[8];
};

static const uint8_t g_unknown_8x8[8] = {
	0b00111100,
	0b01000010,
	0b00000100,
	0b00001000,
	0b00010000,
	0b00000000,
	0b00010000,
	0b00000000,
};

static const struct glyph8 g_glyphs_8x8[] = {
	/* Space */
	{' ', {0, 0, 0, 0, 0, 0, 0, 0}},

	/* Digits 0-9 */
	{'0', {0x3C, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x3C, 0x00}},
	{'1', {0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}},
	{'2', {0x3C, 0x66, 0x06, 0x0C, 0x18, 0x30, 0x7E, 0x00}},
	{'3', {0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00}},
	{'4', {0x0C, 0x1C, 0x3C, 0x6C, 0x7E, 0x0C, 0x0C, 0x00}},
	{'5', {0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00}},
	{'6', {0x1C, 0x30, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00}},
	{'7', {0x7E, 0x66, 0x06, 0x0C, 0x18, 0x18, 0x18, 0x00}},
	{'8', {0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00}},
	{'9', {0x3C, 0x66, 0x66, 0x3E, 0x06, 0x0C, 0x38, 0x00}},

	/* Uppercase A-Z */
	{'A', {0x18, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00}},
	{'B', {0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00}},
	{'C', {0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00}},
	{'D', {0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00}},
	{'E', {0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x7E, 0x00}},
	{'F', {0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x00}},
	{'G', {0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00}},
	{'H', {0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00}},
	{'I', {0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}},
	{'J', {0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00}},
	{'K', {0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00}},
	{'L', {0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00}},
	{'M', {0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00}},
	{'N', {0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00}},
	{'O', {0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00}},
	{'P', {0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00}},
	{'Q', {0x3C, 0x66, 0x66, 0x66, 0x6E, 0x3C, 0x0E, 0x00}},
	{'R', {0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00}},
	{'S', {0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00}},
	{'T', {0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}},
	{'U', {0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00}},
	{'V', {0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00}},
	{'W', {0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00}},
	{'X', {0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00}},
	{'Y', {0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x3C, 0x00}},
	{'Z', {0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00}},

	/* German umlauts + ß (Latin-1) */
	{0xC4, {0x66, 0x18, 0x3C, 0x66, 0x7E, 0x66, 0x66, 0x00}}, /* Ä */
	{0xD6, {0x66, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00}}, /* Ö */
	{0xDC, {0x66, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00}}, /* Ü */
	{0xE4, {0x66, 0x18, 0x3C, 0x66, 0x7E, 0x66, 0x66, 0x00}}, /* ä */
	{0xF6, {0x66, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00}}, /* ö */
	{0xFC, {0x66, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00}}, /* ü */
	{0xDF, {0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x7C, 0x00}}, /* ß */

	/* Common Latin-1 accents seen on Wikipedia (authored in-repo). */
	{0xE9, {0x0C, 0x18, 0x7E, 0x60, 0x7C, 0x60, 0x7E, 0x00}}, /* é */
	{0xE8, {0x30, 0x18, 0x7E, 0x60, 0x7C, 0x60, 0x7E, 0x00}}, /* è */
	{0xEA, {0x18, 0x3C, 0x7E, 0x60, 0x7C, 0x60, 0x7E, 0x00}}, /* ê */
	{0xEB, {0x66, 0x00, 0x7E, 0x60, 0x7C, 0x60, 0x7E, 0x00}}, /* ë */
	{0xE0, {0x30, 0x18, 0x18, 0x3C, 0x66, 0x7E, 0x66, 0x00}}, /* à */
	{0xE1, {0x0C, 0x18, 0x18, 0x3C, 0x66, 0x7E, 0x66, 0x00}}, /* á */
	{0xE2, {0x18, 0x3C, 0x18, 0x3C, 0x66, 0x7E, 0x66, 0x00}}, /* â */
	{0xE5, {0x18, 0x24, 0x18, 0x3C, 0x66, 0x7E, 0x66, 0x00}}, /* å */
	{0xF1, {0x32, 0x4C, 0x66, 0x76, 0x7E, 0x6E, 0x66, 0x00}}, /* ñ */
	{0xE7, {0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x18}}, /* ç */
	{0xEC, {0x30, 0x18, 0x00, 0x18, 0x18, 0x18, 0x3C, 0x00}}, /* ì */
	{0xED, {0x0C, 0x18, 0x00, 0x18, 0x18, 0x18, 0x3C, 0x00}}, /* í */
	{0xEE, {0x18, 0x3C, 0x00, 0x18, 0x18, 0x18, 0x3C, 0x00}}, /* î */
	{0xF2, {0x30, 0x18, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00}}, /* ò */
	{0xF4, {0x18, 0x3C, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00}}, /* ô */
	{0xF5, {0x32, 0x4C, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00}}, /* õ */
	{0xF8, {0x3C, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x3C, 0x00}}, /* ø (reuse slashed-0 style) */
	{0xF9, {0x30, 0x18, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00}}, /* ù */
	{0xB0, {0x18, 0x24, 0x24, 0x18, 0x00, 0x00, 0x00, 0x00}}, /* ° */
	{0xC9, {0x0C, 0x18, 0x7E, 0x60, 0x7C, 0x60, 0x7E, 0x00}}, /* É */
	{0xCD, {0x0C, 0x18, 0x3C, 0x18, 0x18, 0x18, 0x3C, 0x00}}, /* Í */
	{0xC6, {0x3E, 0x6C, 0x6C, 0x7E, 0x6C, 0x6C, 0x6E, 0x00}}, /* Æ */

	/* Punctuation (matches prior in-browser expectations) */
	{'!', {0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00}},
	{'"', {0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00}},
	{'\'', {0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00}},
	{',', {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30}},
	{'.', {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00}},
	{'?', {0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x18, 0x00}},
	{':', {0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00}},
	{';', {0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30}},
	{'/', {0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00}},
	{'\\', {0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00}},
	{'-', {0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00}},
	{'_', {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00}},
	{'[', {0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00}},
	{']', {0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00}},
	{'(', {0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00}},
	{')', {0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00}},
	{'{', {0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00}},
	{'}', {0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00}},
	{'=', {0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00}},
	{'+', {0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00}},
	{'*', {0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00}},
	{'>', {0x00, 0x40, 0x60, 0x30, 0x18, 0x30, 0x60, 0x40}},
	{'<', {0x00, 0x02, 0x06, 0x0C, 0x18, 0x0C, 0x06, 0x02}},
	{'|', {0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00}},
	{'~', {0x00, 0x00, 0x32, 0x4C, 0x00, 0x00, 0x00, 0x00}},
	{'^', {0x18, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00}},
	{'@', {0x3C, 0x42, 0x9D, 0xA5, 0x9D, 0x41, 0x3E, 0x00}},
	{'$', {0x18, 0x3E, 0x58, 0x3C, 0x1A, 0x7C, 0x18, 0x00}},
	{'#', {0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00}},
	{'%', {0x62, 0x64, 0x08, 0x10, 0x26, 0x46, 0x00, 0x00}},
	{'&', {0x1C, 0x22, 0x14, 0x18, 0x25, 0x22, 0x1D, 0x00}},
};

static void buf_append(char **buf, size_t *len, size_t *cap, const char *s)
{
	size_t sl = strlen(s);
	if (*len + sl + 1 > *cap) {
		size_t ncap = (*cap == 0) ? 4096 : *cap;
		while (*len + sl + 1 > ncap) ncap *= 2;
		char *nbuf = (char *)realloc(*buf, ncap);
		if (!nbuf) {
			fprintf(stderr, "fontgen: OOM\n");
			exit(1);
		}
		*buf = nbuf;
		*cap = ncap;
	}
	memcpy(*buf + *len, s, sl);
	*len += sl;
	(*buf)[*len] = 0;
}

static void buf_printf(char **buf, size_t *len, size_t *cap, const char *fmt, ...)
{
	va_list ap;
	va_start(ap, fmt);
	char tmp[1024];
	int n = vsnprintf(tmp, sizeof(tmp), fmt, ap);
	va_end(ap);
	if (n < 0) {
		fprintf(stderr, "fontgen: vsnprintf failed\n");
		exit(1);
	}
	if ((size_t)n >= sizeof(tmp)) {
		fprintf(stderr, "fontgen: line too long\n");
		exit(1);
	}
	buf_append(buf, len, cap, tmp);
}

static char *read_entire_file(const char *path, size_t *out_len)
{
	FILE *f = fopen(path, "rb");
	if (!f) return NULL;
	if (fseek(f, 0, SEEK_END) != 0) {
		fclose(f);
		return NULL;
	}
	long sz = ftell(f);
	if (sz < 0) {
		fclose(f);
		return NULL;
	}
	if (fseek(f, 0, SEEK_SET) != 0) {
		fclose(f);
		return NULL;
	}
	char *buf = (char *)malloc((size_t)sz + 1);
	if (!buf) {
		fclose(f);
		return NULL;
	}
	size_t n = fread(buf, 1, (size_t)sz, f);
	fclose(f);
	buf[n] = 0;
	if (out_len) *out_len = n;
	return buf;
}

static void write_if_changed(const char *path, const char *content)
{
	size_t old_len = 0;
	char *old = read_entire_file(path, &old_len);
	if (old && strcmp(old, content) == 0) {
		free(old);
		return;
	}
	free(old);

	FILE *f = fopen(path, "wb");
	if (!f) {
		fprintf(stderr, "fontgen: open %s failed: %s\n", path, strerror(errno));
		exit(1);
	}
	size_t n = fwrite(content, 1, strlen(content), f);
	if (n != strlen(content)) {
		fprintf(stderr, "fontgen: write %s failed\n", path);
		fclose(f);
		exit(1);
	}
	fclose(f);
}

static void emit_glyph_array_8x8(char **buf, size_t *len, size_t *cap, const char *name, const uint8_t rows[8])
{
	buf_printf(buf, len, cap, "static const uint8_t %s[8] = { ", name);
	for (int i = 0; i < 8; i++) {
		buf_printf(buf, len, cap, "0x%02X%s", rows[i], (i == 7) ? "" : ", ");
	}
	buf_append(buf, len, cap, " };\n");
}

static void emit_glyph_array_8x16_scaled(char **buf, size_t *len, size_t *cap, const char *name, const uint8_t rows8[8])
{
	buf_printf(buf, len, cap, "static const uint8_t %s[16] = { ", name);
	for (int i = 0; i < 8; i++) {
		buf_printf(buf, len, cap, "0x%02X, 0x%02X%s", rows8[i], rows8[i], (i == 7) ? "" : ", ");
	}
	buf_append(buf, len, cap, " };\n");
}

static void generate_font_file_8x8(const char *out_path)
{
	char *buf = NULL;
	size_t len = 0, cap = 0;

	buf_append(&buf, &len, &cap,
		"/* Auto-generated by tools/fontgen.c. Do not edit by hand. */\n"
		"#include \"font.h\"\n\n");

	emit_glyph_array_8x8(&buf, &len, &cap, "g_unknown", g_unknown_8x8);

	for (size_t i = 0; i < sizeof(g_glyphs_8x8) / sizeof(g_glyphs_8x8[0]); i++) {
		const struct glyph8 *g = &g_glyphs_8x8[i];
		char name[64];
		snprintf(name, sizeof(name), "g_%02X", (unsigned)g->ch);
		emit_glyph_array_8x8(&buf, &len, &cap, name, g->rows);
	}

	buf_append(&buf, &len, &cap, "\nstatic struct font_glyph glyph_for_8x8(unsigned char c)\n{\n");
	buf_append(&buf, &len, &cap, "\tif (c >= 'a' && c <= 'z') c = (unsigned char)(c - 'a' + 'A');\n");
	buf_append(&buf, &len, &cap, "\tswitch (c) {\n");

	for (size_t i = 0; i < sizeof(g_glyphs_8x8) / sizeof(g_glyphs_8x8[0]); i++) {
		const struct glyph8 *g = &g_glyphs_8x8[i];
		buf_printf(&buf, &len, &cap,
			"\tcase 0x%02X: return (struct font_glyph){ .w = 8, .h = 8, .advance = 8, .rows = g_%02X };\n",
			(unsigned)g->ch, (unsigned)g->ch);
	}

	buf_append(&buf, &len, &cap,
		"\tdefault:\n"
		"#ifdef FONT_LOG_MISSING_GLYPHS\n"
		"\t\tfont_log_missing_glyph(c);\n"
		"#endif\n"
		"\t\treturn (struct font_glyph){ .w = 8, .h = 8, .advance = 8, .rows = g_unknown };\n"
		"\t}\n"
		"}\n\n");

	buf_append(&buf, &len, &cap,
		"const struct bitmap_font g_font_8x8 = {\n"
		"\t.cell_w = 8,\n"
		"\t.cell_h = 8,\n"
		"\t.glyph_for = glyph_for_8x8,\n"
		"\t.name = \"builtin-8x8\",\n"
		"};\n");

	write_if_changed(out_path, buf ? buf : "");
	free(buf);
}

static void generate_font_file_8x16_scaled(const char *out_path)
{
	char *buf = NULL;
	size_t len = 0, cap = 0;

	buf_append(&buf, &len, &cap,
		"/* Auto-generated by tools/fontgen.c. Do not edit by hand. */\n"
		"#include \"font.h\"\n\n");

	/* scale fallback */
	emit_glyph_array_8x16_scaled(&buf, &len, &cap, "g_unknown", g_unknown_8x8);

	for (size_t i = 0; i < sizeof(g_glyphs_8x8) / sizeof(g_glyphs_8x8[0]); i++) {
		const struct glyph8 *g = &g_glyphs_8x8[i];
		char name[64];
		snprintf(name, sizeof(name), "g_%02X", (unsigned)g->ch);
		emit_glyph_array_8x16_scaled(&buf, &len, &cap, name, g->rows);
	}

	buf_append(&buf, &len, &cap, "\nstatic struct font_glyph glyph_for_8x16(unsigned char c)\n{\n");
	buf_append(&buf, &len, &cap, "\tif (c >= 'a' && c <= 'z') c = (unsigned char)(c - 'a' + 'A');\n");
	buf_append(&buf, &len, &cap, "\tswitch (c) {\n");

	for (size_t i = 0; i < sizeof(g_glyphs_8x8) / sizeof(g_glyphs_8x8[0]); i++) {
		const struct glyph8 *g = &g_glyphs_8x8[i];
		buf_printf(&buf, &len, &cap,
			"\tcase 0x%02X: return (struct font_glyph){ .w = 8, .h = 16, .advance = 8, .rows = g_%02X };\n",
			(unsigned)g->ch, (unsigned)g->ch);
	}

	buf_append(&buf, &len, &cap,
		"\tdefault:\n"
		"#ifdef FONT_LOG_MISSING_GLYPHS\n"
		"\t\tfont_log_missing_glyph(c);\n"
		"#endif\n"
		"\t\treturn (struct font_glyph){ .w = 8, .h = 16, .advance = 8, .rows = g_unknown };\n"
		"\t}\n"
		"}\n\n");

	buf_append(&buf, &len, &cap,
		"const struct bitmap_font g_font_8x16 = {\n"
		"\t.cell_w = 8,\n"
		"\t.cell_h = 16,\n"
		"\t.glyph_for = glyph_for_8x16,\n"
		"\t.name = \"builtin-8x16-scaled\",\n"
		"};\n");

	write_if_changed(out_path, buf ? buf : "");
	free(buf);
}

static void usage(const char *argv0)
{
	fprintf(stderr, "usage: %s [--out-dir DIR]\n", argv0);
}

int main(int argc, char **argv)
{
	const char *out_dir = "src/core/font";
	for (int i = 1; i < argc; i++) {
		if (strcmp(argv[i], "--out-dir") == 0) {
			if (i + 1 >= argc) {
				usage(argv[0]);
				return 2;
			}
			out_dir = argv[++i];
			continue;
		}
		usage(argv[0]);
		return 2;
	}

	char out8[512];
	char out16[512];
	snprintf(out8, sizeof(out8), "%s/font_builtin_8x8.c", out_dir);
	snprintf(out16, sizeof(out16), "%s/font_builtin_8x16.c", out_dir);

	generate_font_file_8x8(out8);
	generate_font_file_8x16_scaled(out16);
	return 0;
}
